from __future__ import annotations
import json
from textwrap import dedent
import time, random, threading, traceback, shutil
from pathlib import Path

import requests
from .config import load
from .client import queue_next_job, report_progress, push_inventory
from .utils import download_file, sha256_of_file, get_model_path, list_model_hashes

_cfg = load()
MIN_FREE_MB = int(_cfg.get("min_free_mb", 2048))
MAX_RETRIES = int(_cfg.get("max_retries", 5))
BACKOFF_BASE = int(_cfg.get("backoff_base", 2))

CHECK_INTERVAL_IDLE = 10
SLEEP_AFTER_ERROR = 5
KNOWN_HASHES = set(list_model_hashes())

def _enough_free_space(path: Path, min_mb: int = MIN_FREE_MB) -> bool:
    free = shutil.disk_usage(path).free // (1024 * 1024)
    return free >= min_mb


def _already_have(hash_: str | None) -> bool:
    return hash_ in KNOWN_HASHES if hash_ else False


def _download_with_retry(url: str, tmp: Path, progress_cb):
    for attempt in range(1, MAX_RETRIES + 1):
        try:
            download_file(url, tmp, progress_cb)
            return
        except Exception:
            tmp.unlink(missing_ok=True)
            if attempt == MAX_RETRIES:
                raise
            time.sleep(BACKOFF_BASE ** attempt + random.uniform(0, 1))


def _save_preview(url: str, model_path: Path) -> str | None:
    if not url:
        return None
    suffix        = Path(url).suffix or ".png"
    preview_file  = model_path.with_name(model_path.stem + "_preview" + suffix)
    try:
        with requests.get(url, stream=True, timeout=20) as r:
            r.raise_for_status()
            with open(preview_file, "wb") as f:
                for chunk in r.iter_content(8192):
                    f.write(chunk)
        return preview_file.name
    except Exception:
        return None
    

def _write_info_json(meta: dict, sha_local: str, preview_name: str | None,
                     model_path: Path):
    info = {
        "schema": 1,
        "modelId": meta.get("modelId"),
        "versionId": meta.get("id"),
        "name": meta.get("modelTitle"),
        "type": meta.get("type"),
        "about": meta.get("aboutThisVersion"),
        "activationTags": meta.get("activationTags"),
        "sha256": sha_local,
        "previewFile": preview_name,
        "arcencielUrl": f"https://arcenciel.io/models/{meta.get('modelId')}",
    }
    (model_path.parent / (model_path.stem + ".arcenciel.info")
     ).write_text(json.dumps(info, indent=2, ensure_ascii=False))


def _write_html(meta: dict, preview_name: str | None, model_path: Path):
    html = dedent(f"""
    <!doctype html><html lang="en"><meta charset="utf-8">
    <title>{meta.get('modelTitle','ArcEnCiel Model')}</title>
    <style>
      body{{font-family:system-ui, sans-serif; max-width:720px; margin:2rem auto; line-height:1.5}}
      img{{max-width:100%; border-radius:8px; box-shadow:0 2px 8px #0003}}
      pre{{background:#f8f8f8; padding:0.75rem 1rem; border-radius:6px; overflow:auto}}
      .tag{{display:inline-block; background:#eef; color:#226; padding:2px 6px;
            border-radius:4px; margin:2px; font-size:90%}}
    </style>
    <h1>{meta.get('modelTitle','')}</h1>
    """)
    if preview_name:
        html += f'<img src="{preview_name}" alt="preview">'
    if meta.get("aboutThisVersion"):
        html += f"<h2>About this version</h2><p>{meta['aboutThisVersion']}</p>"
    if (tags := meta.get("activationTags")):
        html += "<h2>Activation Tags</h2>" + \
                "".join(f'<span class="tag">{t}</span>' for t in tags)
    html += f"""
    <hr><p><small>Generated by <b>Arc en Ciel Link</b><br>
    sha256: {meta.get('sha256','')}</small></p></html>
    """
    (model_path.parent / (model_path.stem + ".arcenciel.html")).write_text(html)


def _worker():
    while True:
        job = queue_next_job()
        if not job:
            time.sleep(CHECK_INTERVAL_IDLE)
            continue

        try:
            ver = job["version"]
            meta = (ver.get("meta") or {})
            url = ver.get("filePath") or ver.get("externalDownloadUrl")
            if not url:
                raise RuntimeError("No download URL provided by server")

            sha_server = ver.get("sha256")
            dst_path   = get_model_path(job["targetPath"]) / Path(url).name
            dst_path.parent.mkdir(parents=True, exist_ok=True)

            # free-space guard
            if not _enough_free_space(dst_path.parent):
                report_progress(job["id"], state="ERROR",
                                message=f"Less than {MIN_FREE_MB} MB free")
                continue

            # already have?
            if sha_server and _already_have(sha_server):
                report_progress(job["id"], state="DONE", progress=100)
                continue

            # download â†“ tmp
            tmp_path = dst_path.with_suffix(".part")
            report_progress(job["id"], state="DOWNLOADING", progress=0)

            _download_with_retry(url, tmp_path,
                                 lambda p: report_progress(job["id"],
                                                            progress=int(p*100)))

            # hash
            sha_local = sha256_of_file(tmp_path)
            if sha_server and sha_local != sha_server:
                tmp_path.unlink(missing_ok=True)
                raise RuntimeError("SHA-256 mismatch")

            tmp_path.rename(dst_path)

            # side-cars
            preview_name = _save_preview(meta.get("preview"), dst_path)
            _write_info_json(meta, sha_local, preview_name, dst_path)
            _write_html(meta | {"sha256": sha_local}, preview_name, dst_path)

            # done
            push_inventory([sha_local])
            KNOWN_HASHES.add(sha_local)
            report_progress(job["id"], state="DONE", progress=100)

        except Exception as e:
            traceback.print_exc()
            report_progress(job["id"], state="ERROR", message=str(e))
            time.sleep(SLEEP_AFTER_ERROR)


def start_worker():
    threading.Thread(target=_worker, daemon=True).start()


def _inventory_loop():
    while True:
        try:
            push_inventory(list_model_hashes())
        except Exception:
            pass
        time.sleep(3600)


def schedule_inventory_push():
    threading.Thread(target=_inventory_loop, daemon=True).start()


start_worker()
